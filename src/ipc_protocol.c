/* ipc_protocol.c -- generated by Trunnel v1.4.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 *
 * sysrqb: Edited, making it C++ compliant
 */
#include <stdlib.h>
#include <internal/trunnel-impl.h>

#include <internal/ipc_protocol.h>

#define TRUNNEL_SET_ERROR_CODE(obj) \
  do {                              \
    (obj)->trunnel_error_code_ = 1; \
  } while (0)

#if defined(__COVERITY__) || defined(__clang_analyzer__)
/* If we're runnning a static analysis tool, we don't want it to complain
 * that some of our remaining-bytes checks are dead-code. */
int ipcprotocol_deadcode_dummy__ = 0;
#define OR_DEADCODE_DUMMY || ipcprotocol_deadcode_dummy__
#else
#define OR_DEADCODE_DUMMY
#endif

#define CHECK_REMAINING(nbytes, label)                           \
  do {                                                           \
    if (remaining < (nbytes) OR_DEADCODE_DUMMY) {                \
      goto label;                                                \
    }                                                            \
  } while (0)

control_comm_method_t *
control_comm_method_new(void)
{
  control_comm_method_t *val = (control_comm_method_t *) trunnel_calloc(1, sizeof(control_comm_method_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
control_comm_method_clear(control_comm_method_t *obj)
{
  (void) obj;
}

void
control_comm_method_free(control_comm_method_t *obj)
{
  if (obj == NULL)
    return;
  control_comm_method_clear(obj);
  trunnel_memwipe(obj, sizeof(control_comm_method_t));
  trunnel_free_(obj);
}

uint8_t
control_comm_method_get_device(control_comm_method_t *inp)
{
  return inp->device;
}
int
control_comm_method_set_device(control_comm_method_t *inp, uint8_t val)
{
  inp->device = val;
  return 0;
}
uint16_t
control_comm_method_get_method_fd(control_comm_method_t *inp)
{
  return inp->method_fd;
}
int
control_comm_method_set_method_fd(control_comm_method_t *inp, uint16_t val)
{
  inp->method_fd = val;
  return 0;
}
const char *
control_comm_method_check(const control_comm_method_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  switch (obj->device) {

    case COMM_DEV_FILEDESCR:
      break;

    case COMM_DEV_CALLBACK:
        return "Bad tag for union";
      break;

    case COMM_DEV_INTERNAL:
        return "Bad tag for union";
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
control_comm_method_encoded_len(const control_comm_method_t *obj)
{
  ssize_t result = 0;

  if (NULL != control_comm_method_check(obj))
     return -1;


  /* Length of u8 device */
  result += 1;
  switch (obj->device) {

    case COMM_DEV_FILEDESCR:

      /* Length of u16 method_fd */
      result += 2;
      break;

    case COMM_DEV_CALLBACK:
      trunnel_assert(0);
      break;

    case COMM_DEV_INTERNAL:
      trunnel_assert(0);
      break;

    default:
      trunnel_assert(0);
      break;
  }
  return result;
}
int
control_comm_method_clear_errors(control_comm_method_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
control_comm_method_encode(uint8_t *output, const size_t avail, const control_comm_method_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = control_comm_method_encoded_len(obj);
#endif

  if (NULL != (msg = control_comm_method_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 device */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->device));
  written += 1; ptr += 1;

  /* Encode union method[device] */
  trunnel_assert(written <= avail);
  switch (obj->device) {

    case COMM_DEV_FILEDESCR:

      /* Encode u16 method_fd */
      trunnel_assert(written <= avail);
      if (avail - written < 2)
        goto truncated;
      trunnel_set_uint16(ptr, trunnel_htons(obj->method_fd));
      written += 2; ptr += 2;
      break;

    case COMM_DEV_CALLBACK:
      trunnel_assert(0);
      break;

    case COMM_DEV_INTERNAL:
      trunnel_assert(0);
      break;

    default:
      trunnel_assert(0);
      break;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As control_comm_method_parse(), but do not allocate the output
 * object.
 */
static ssize_t
control_comm_method_parse_into(control_comm_method_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 device */
  CHECK_REMAINING(1, truncated);
  obj->device = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse union method[device] */
  switch (obj->device) {

    case COMM_DEV_FILEDESCR:

      /* Parse u16 method_fd */
      CHECK_REMAINING(2, truncated);
      obj->method_fd = trunnel_ntohs(trunnel_get_uint16(ptr));
      remaining -= 2; ptr += 2;
      break;

    case COMM_DEV_CALLBACK:
      goto fail;
      break;

    case COMM_DEV_INTERNAL:
      goto fail;
      break;

    default:
      goto fail;
      break;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
control_comm_method_parse(control_comm_method_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = control_comm_method_new();
  if (NULL == *output)
    return -1;
  result = control_comm_method_parse_into(*output, input, len_in);
  if (result < 0) {
    control_comm_method_free(*output);
    *output = NULL;
  }
  return result;
}
control_fatality_t *
control_fatality_new(void)
{
  control_fatality_t *val = (control_fatality_t *) trunnel_calloc(1, sizeof(control_fatality_t));
  if (NULL == val)
    return NULL;
  val->fatality_time = FATALITY_ASAP;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
control_fatality_clear(control_fatality_t *obj)
{
  (void) obj;
  trunnel_wipestr(obj->message);
  trunnel_free(obj->message);
}

void
control_fatality_free(control_fatality_t *obj)
{
  if (obj == NULL)
    return;
  control_fatality_clear(obj);
  trunnel_memwipe(obj, sizeof(control_fatality_t));
  trunnel_free_(obj);
}

uint8_t
control_fatality_get_fatality_time(control_fatality_t *inp)
{
  return inp->fatality_time;
}
int
control_fatality_set_fatality_time(control_fatality_t *inp, uint8_t val)
{
  if (! ((val == FATALITY_ASAP || val == FATALITY_IMMEDIATE))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->fatality_time = val;
  return 0;
}
const char *
control_fatality_get_message(control_fatality_t *inp)
{
  return inp->message;
}
int
control_fatality_set_message(control_fatality_t *inp, const char *val)
{
  trunnel_free(inp->message);
  if (NULL == (inp->message = trunnel_strdup(val))) {
    TRUNNEL_SET_ERROR_CODE(inp);
    return -1;
  }
  return 0;
}
const char *
control_fatality_check(const control_fatality_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (! (obj->fatality_time == FATALITY_ASAP || obj->fatality_time == FATALITY_IMMEDIATE))
    return "Integer out of bounds";
  if (NULL == obj->message)
    return "Missing message";
  return NULL;
}

ssize_t
control_fatality_encoded_len(const control_fatality_t *obj)
{
  ssize_t result = 0;

  if (NULL != control_fatality_check(obj))
     return -1;


  /* Length of u8 fatality_time IN [FATALITY_ASAP, FATALITY_IMMEDIATE] */
  result += 1;

  /* Length of nulterm message */
  result += strlen(obj->message) + 1;
  return result;
}
int
control_fatality_clear_errors(control_fatality_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
control_fatality_encode(uint8_t *output, const size_t avail, const control_fatality_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = control_fatality_encoded_len(obj);
#endif

  if (NULL != (msg = control_fatality_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 fatality_time IN [FATALITY_ASAP, FATALITY_IMMEDIATE] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->fatality_time));
  written += 1; ptr += 1;

  /* Encode nulterm message */
  {
    size_t len = strlen(obj->message);
    trunnel_assert(written <= avail);
    if (avail - written < len + 1)
      goto truncated;
    memcpy(ptr, obj->message, len + 1);
    ptr += len + 1; written += len + 1;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As control_fatality_parse(), but do not allocate the output
 * object.
 */
static ssize_t
control_fatality_parse_into(control_fatality_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 fatality_time IN [FATALITY_ASAP, FATALITY_IMMEDIATE] */
  CHECK_REMAINING(1, truncated);
  obj->fatality_time = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->fatality_time == FATALITY_ASAP || obj->fatality_time == FATALITY_IMMEDIATE))
    goto fail;

  /* Parse nulterm message */
  {
    uint8_t *eos = (uint8_t*)memchr(ptr, 0, remaining);
    size_t memlen;
    if (eos == NULL)
      goto truncated;
    trunnel_assert(eos >= ptr);
    trunnel_assert((size_t)(eos - ptr) < SIZE_MAX - 1);
    memlen = ((size_t)(eos - ptr)) + 1;
    if (!(obj->message = (char *) trunnel_malloc(memlen)))
      goto fail;
    memcpy(obj->message, ptr, memlen);
    remaining -= memlen; ptr += memlen;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
control_fatality_parse(control_fatality_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = control_fatality_new();
  if (NULL == *output)
    return -1;
  result = control_fatality_parse_into(*output, input, len_in);
  if (result < 0) {
    control_fatality_free(*output);
    *output = NULL;
  }
  return result;
}
control_serial_t *
control_serial_new(void)
{
  control_serial_t *val = (control_serial_t *) trunnel_calloc(1, sizeof(control_serial_t));
  if (NULL == val)
    return NULL;
  val->serialization = SERIAL_BUILTIN;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
control_serial_clear(control_serial_t *obj)
{
  (void) obj;
}

void
control_serial_free(control_serial_t *obj)
{
  if (obj == NULL)
    return;
  control_serial_clear(obj);
  trunnel_memwipe(obj, sizeof(control_serial_t));
  trunnel_free_(obj);
}

uint8_t
control_serial_get_serialization(control_serial_t *inp)
{
  return inp->serialization;
}
int
control_serial_set_serialization(control_serial_t *inp, uint8_t val)
{
  if (! ((val == SERIAL_BUILTIN))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->serialization = val;
  return 0;
}
const char *
control_serial_check(const control_serial_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (! (obj->serialization == SERIAL_BUILTIN))
    return "Integer out of bounds";
  return NULL;
}

ssize_t
control_serial_encoded_len(const control_serial_t *obj)
{
  ssize_t result = 0;

  if (NULL != control_serial_check(obj))
     return -1;


  /* Length of u8 serialization IN [SERIAL_BUILTIN] */
  result += 1;
  return result;
}
int
control_serial_clear_errors(control_serial_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
control_serial_encode(uint8_t *output, const size_t avail, const control_serial_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = control_serial_encoded_len(obj);
#endif

  if (NULL != (msg = control_serial_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 serialization IN [SERIAL_BUILTIN] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->serialization));
  written += 1; ptr += 1;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As control_serial_parse(), but do not allocate the output object.
 */
static ssize_t
control_serial_parse_into(control_serial_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 serialization IN [SERIAL_BUILTIN] */
  CHECK_REMAINING(1, truncated);
  obj->serialization = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->serialization == SERIAL_BUILTIN))
    goto fail;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
control_serial_parse(control_serial_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = control_serial_new();
  if (NULL == *output)
    return -1;
  result = control_serial_parse_into(*output, input, len_in);
  if (result < 0) {
    control_serial_free(*output);
    *output = NULL;
  }
  return result;
}
control_xfer_protocol_t *
control_xfer_protocol_new(void)
{
  control_xfer_protocol_t *val = (control_xfer_protocol_t *) trunnel_calloc(1, sizeof(control_xfer_protocol_t));
  if (NULL == val)
    return NULL;
  val->proto = XFERPROTO_EGL85;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
control_xfer_protocol_clear(control_xfer_protocol_t *obj)
{
  (void) obj;
}

void
control_xfer_protocol_free(control_xfer_protocol_t *obj)
{
  if (obj == NULL)
    return;
  control_xfer_protocol_clear(obj);
  trunnel_memwipe(obj, sizeof(control_xfer_protocol_t));
  trunnel_free_(obj);
}

uint8_t
control_xfer_protocol_get_proto(control_xfer_protocol_t *inp)
{
  return inp->proto;
}
int
control_xfer_protocol_set_proto(control_xfer_protocol_t *inp, uint8_t val)
{
  if (! ((val == XFERPROTO_EGL85))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->proto = val;
  return 0;
}
const char *
control_xfer_protocol_check(const control_xfer_protocol_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (! (obj->proto == XFERPROTO_EGL85))
    return "Integer out of bounds";
  return NULL;
}

ssize_t
control_xfer_protocol_encoded_len(const control_xfer_protocol_t *obj)
{
  ssize_t result = 0;

  if (NULL != control_xfer_protocol_check(obj))
     return -1;


  /* Length of u8 proto IN [XFERPROTO_EGL85] */
  result += 1;
  return result;
}
int
control_xfer_protocol_clear_errors(control_xfer_protocol_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
control_xfer_protocol_encode(uint8_t *output, const size_t avail, const control_xfer_protocol_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = control_xfer_protocol_encoded_len(obj);
#endif

  if (NULL != (msg = control_xfer_protocol_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 proto IN [XFERPROTO_EGL85] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->proto));
  written += 1; ptr += 1;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As control_xfer_protocol_parse(), but do not allocate the output
 * object.
 */
static ssize_t
control_xfer_protocol_parse_into(control_xfer_protocol_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 proto IN [XFERPROTO_EGL85] */
  CHECK_REMAINING(1, truncated);
  obj->proto = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->proto == XFERPROTO_EGL85))
    goto fail;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
control_xfer_protocol_parse(control_xfer_protocol_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = control_xfer_protocol_new();
  if (NULL == *output)
    return -1;
  result = control_xfer_protocol_parse_into(*output, input, len_in);
  if (result < 0) {
    control_xfer_protocol_free(*output);
    *output = NULL;
  }
  return result;
}
domain_status_t *
domain_status_new(void)
{
  domain_status_t *val = (domain_status_t *) trunnel_calloc(1, sizeof(domain_status_t));
  if (NULL == val)
    return NULL;
  val->verbosity = VERBOSITY_DEBUG;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
domain_status_clear(domain_status_t *obj)
{
  (void) obj;
  trunnel_wipestr(obj->msg);
  trunnel_free(obj->msg);
}

void
domain_status_free(domain_status_t *obj)
{
  if (obj == NULL)
    return;
  domain_status_clear(obj);
  trunnel_memwipe(obj, sizeof(domain_status_t));
  trunnel_free_(obj);
}

uint8_t
domain_status_get_verbosity(domain_status_t *inp)
{
  return inp->verbosity;
}
int
domain_status_set_verbosity(domain_status_t *inp, uint8_t val)
{
  if (! ((val == VERBOSITY_DEBUG || val == VERBOSITY_ERROR || val == VERBOSITY_INFO || val == VERBOSITY_NOTICE || val == VERBOSITY_WARNING))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->verbosity = val;
  return 0;
}
uint16_t
domain_status_get_msglen(domain_status_t *inp)
{
  return inp->msglen;
}
int
domain_status_set_msglen(domain_status_t *inp, uint16_t val)
{
  inp->msglen = val;
  return 0;
}
const char *
domain_status_get_msg(domain_status_t *inp)
{
  return inp->msg;
}
int
domain_status_set_msg(domain_status_t *inp, const char *val)
{
  trunnel_free(inp->msg);
  if (NULL == (inp->msg = trunnel_strdup(val))) {
    TRUNNEL_SET_ERROR_CODE(inp);
    return -1;
  }
  return 0;
}
const char *
domain_status_check(const domain_status_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (! (obj->verbosity == VERBOSITY_DEBUG || obj->verbosity == VERBOSITY_ERROR || obj->verbosity == VERBOSITY_INFO || obj->verbosity == VERBOSITY_NOTICE || obj->verbosity == VERBOSITY_WARNING))
    return "Integer out of bounds";
  if (NULL == obj->msg)
    return "Missing msg";
  return NULL;
}

ssize_t
domain_status_encoded_len(const domain_status_t *obj)
{
  ssize_t result = 0;

  if (NULL != domain_status_check(obj))
     return -1;


  /* Length of u8 verbosity IN [VERBOSITY_DEBUG, VERBOSITY_ERROR, VERBOSITY_INFO, VERBOSITY_NOTICE, VERBOSITY_WARNING] */
  result += 1;

  /* Length of u16 msglen */
  result += 2;

  /* Length of nulterm msg */
  result += strlen(obj->msg) + 1;
  return result;
}
int
domain_status_clear_errors(domain_status_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
domain_status_encode(uint8_t *output, const size_t avail, const domain_status_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = domain_status_encoded_len(obj);
#endif

  if (NULL != (msg = domain_status_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 verbosity IN [VERBOSITY_DEBUG, VERBOSITY_ERROR, VERBOSITY_INFO, VERBOSITY_NOTICE, VERBOSITY_WARNING] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->verbosity));
  written += 1; ptr += 1;

  /* Encode u16 msglen */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->msglen));
  written += 2; ptr += 2;

  /* Encode nulterm msg */
  {
    size_t len = strlen(obj->msg);
    trunnel_assert(written <= avail);
    if (avail - written < len + 1)
      goto truncated;
    memcpy(ptr, obj->msg, len + 1);
    ptr += len + 1; written += len + 1;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As domain_status_parse(), but do not allocate the output object.
 */
static ssize_t
domain_status_parse_into(domain_status_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 verbosity IN [VERBOSITY_DEBUG, VERBOSITY_ERROR, VERBOSITY_INFO, VERBOSITY_NOTICE, VERBOSITY_WARNING] */
  CHECK_REMAINING(1, truncated);
  obj->verbosity = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->verbosity == VERBOSITY_DEBUG || obj->verbosity == VERBOSITY_ERROR || obj->verbosity == VERBOSITY_INFO || obj->verbosity == VERBOSITY_NOTICE || obj->verbosity == VERBOSITY_WARNING))
    goto fail;

  /* Parse u16 msglen */
  CHECK_REMAINING(2, truncated);
  obj->msglen = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse nulterm msg */
  {
    uint8_t *eos = (uint8_t*)memchr(ptr, 0, remaining);
    size_t memlen;
    if (eos == NULL)
      goto truncated;
    trunnel_assert(eos >= ptr);
    trunnel_assert((size_t)(eos - ptr) < SIZE_MAX - 1);
    memlen = ((size_t)(eos - ptr)) + 1;
    if (!(obj->msg = (char *) trunnel_malloc(memlen)))
      goto fail;
    memcpy(obj->msg, ptr, memlen);
    remaining -= memlen; ptr += memlen;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 fail:
  result = -1;
  return result;
}

ssize_t
domain_status_parse(domain_status_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = domain_status_new();
  if (NULL == *output)
    return -1;
  result = domain_status_parse_into(*output, input, len_in);
  if (result < 0) {
    domain_status_free(*output);
    *output = NULL;
  }
  return result;
}
proto_egl85_messages_t *
proto_egl85_messages_new(void)
{
  proto_egl85_messages_t *val = (proto_egl85_messages_t *) trunnel_calloc(1, sizeof(proto_egl85_messages_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
proto_egl85_messages_clear(proto_egl85_messages_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_WIPE(&obj->msglens);
  TRUNNEL_DYNARRAY_CLEAR(&obj->msglens);
  TRUNNEL_DYNARRAY_WIPE(&obj->msgs);
  TRUNNEL_DYNARRAY_CLEAR(&obj->msgs);
}

void
proto_egl85_messages_free(proto_egl85_messages_t *obj)
{
  if (obj == NULL)
    return;
  proto_egl85_messages_clear(obj);
  trunnel_memwipe(obj, sizeof(proto_egl85_messages_t));
  trunnel_free_(obj);
}

uint32_t
proto_egl85_messages_get_msgslen(proto_egl85_messages_t *inp)
{
  return inp->msgslen;
}
int
proto_egl85_messages_set_msgslen(proto_egl85_messages_t *inp, uint32_t val)
{
  inp->msgslen = val;
  return 0;
}
uint8_t
proto_egl85_messages_get_msgcount(proto_egl85_messages_t *inp)
{
  return inp->msgcount;
}
int
proto_egl85_messages_set_msgcount(proto_egl85_messages_t *inp, uint8_t val)
{
  inp->msgcount = val;
  return 0;
}
size_t
proto_egl85_messages_getlen_msglens(const proto_egl85_messages_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->msglens);
}

uint32_t
proto_egl85_messages_get_msglens(proto_egl85_messages_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->msglens, idx);
}

int
proto_egl85_messages_set_msglens(proto_egl85_messages_t *inp, size_t idx, uint32_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->msglens, idx, elt);
  return 0;
}
int
proto_egl85_messages_add_msglens(proto_egl85_messages_t *inp, uint32_t elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->msglens.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint32_t, &inp->msglens, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint32_t *
proto_egl85_messages_getarray_msglens(proto_egl85_messages_t *inp)
{
  return inp->msglens.elts_;
}
int
proto_egl85_messages_setlen_msglens(proto_egl85_messages_t *inp, size_t newlen)
{
  uint32_t *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = (uint32_t *) trunnel_dynarray_setlen(&inp->msglens.allocated_,
                 &inp->msglens.n_, inp->msglens.elts_, newlen,
                 sizeof(inp->msglens.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newptr == NULL)
    goto trunnel_alloc_failed;
  inp->msglens.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
size_t
proto_egl85_messages_getlen_msgs(const proto_egl85_messages_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->msgs);
}

char
proto_egl85_messages_get_msgs(proto_egl85_messages_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->msgs, idx);
}

int
proto_egl85_messages_set_msgs(proto_egl85_messages_t *inp, size_t idx, char elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->msgs, idx, elt);
  return 0;
}
int
proto_egl85_messages_add_msgs(proto_egl85_messages_t *inp, char elt)
{
#if SIZE_MAX >= UINT32_MAX
  if (inp->msgs.n_ == UINT32_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(char, &inp->msgs, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

char *
proto_egl85_messages_getarray_msgs(proto_egl85_messages_t *inp)
{
  return inp->msgs.elts_;
}
int
proto_egl85_messages_setlen_msgs(proto_egl85_messages_t *inp, size_t newlen)
{
#if UINT32_MAX < SIZE_MAX
  if (newlen > UINT32_MAX)
    goto trunnel_alloc_failed;
#endif
  return trunnel_string_setlen(&inp->msgs, newlen,
            &inp->trunnel_error_code_);
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
proto_egl85_messages_getstr_msgs(proto_egl85_messages_t *inp)
{
  return trunnel_string_getstr(&inp->msgs);
}
int
proto_egl85_messages_setstr0_msgs(proto_egl85_messages_t *inp, const char *val, size_t len)
{
#if UINT32_MAX < SIZE_MAX
  if (len > UINT32_MAX) {
    TRUNNEL_SET_ERROR_CODE(inp);
    return -1;
  }
#endif
  return trunnel_string_setstr0(&inp->msgs, val, len, &inp->trunnel_error_code_);
}
int
proto_egl85_messages_setstr_msgs(proto_egl85_messages_t *inp, const char *val)
{
  return proto_egl85_messages_setstr0_msgs(inp, val, strlen(val));
}
const char *
proto_egl85_messages_check(const proto_egl85_messages_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (TRUNNEL_DYNARRAY_LEN(&obj->msglens) != obj->msgcount)
    return "Length mismatch for msglens";
  if (TRUNNEL_DYNARRAY_LEN(&obj->msgs) != obj->msgslen)
    return "Length mismatch for msgs";
  return NULL;
}

ssize_t
proto_egl85_messages_encoded_len(const proto_egl85_messages_t *obj)
{
  ssize_t result = 0;

  if (NULL != proto_egl85_messages_check(obj))
     return -1;


  /* Length of u32 msgslen */
  result += 4;

  /* Length of u8 msgcount */
  result += 1;

  /* Length of u32 msglens[msgcount] */
  result += 4 * TRUNNEL_DYNARRAY_LEN(&obj->msglens);

  /* Length of char msgs[msgslen] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->msgs);
  return result;
}
int
proto_egl85_messages_clear_errors(proto_egl85_messages_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
proto_egl85_messages_encode(uint8_t *output, const size_t avail, const proto_egl85_messages_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = proto_egl85_messages_encoded_len(obj);
#endif

  if (NULL != (msg = proto_egl85_messages_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u32 msgslen */
  trunnel_assert(written <= avail);
  if (avail - written < 4)
    goto truncated;
  trunnel_set_uint32(ptr, trunnel_htonl(obj->msgslen));
  written += 4; ptr += 4;

  /* Encode u8 msgcount */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->msgcount));
  written += 1; ptr += 1;

  /* Encode u32 msglens[msgcount] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->msglens); ++idx) {
      trunnel_assert(written <= avail);
      if (avail - written < 4)
        goto truncated;
      trunnel_set_uint32(ptr, trunnel_htonl(TRUNNEL_DYNARRAY_GET(&obj->msglens, idx)));
      written += 4; ptr += 4;
    }
  }

  /* Encode char msgs[msgslen] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->msgs);
    trunnel_assert(obj->msgslen == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    memcpy(ptr, obj->msgs.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As proto_egl85_messages_parse(), but do not allocate the output
 * object.
 */
static ssize_t
proto_egl85_messages_parse_into(proto_egl85_messages_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u32 msgslen */
  CHECK_REMAINING(4, truncated);
  obj->msgslen = trunnel_ntohl(trunnel_get_uint32(ptr));
  remaining -= 4; ptr += 4;

  /* Parse u8 msgcount */
  CHECK_REMAINING(1, truncated);
  obj->msgcount = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u32 msglens[msgcount] */
  TRUNNEL_DYNARRAY_EXPAND(uint32_t, &obj->msglens, obj->msgcount, {});
  {
    uint32_t elt;
    unsigned idx;
    for (idx = 0; idx < obj->msgcount; ++idx) {
      CHECK_REMAINING(4, truncated);
      elt = trunnel_ntohl(trunnel_get_uint32(ptr));
      remaining -= 4; ptr += 4;
      TRUNNEL_DYNARRAY_ADD(uint32_t, &obj->msglens, elt, {});
    }
  }

  /* Parse char msgs[msgslen] */
  CHECK_REMAINING(obj->msgslen, truncated);
  if (proto_egl85_messages_setstr0_msgs(obj, (const char*)ptr, obj->msgslen))
    goto fail;
  ptr += obj->msgslen; remaining -= obj->msgslen;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 trunnel_alloc_failed:
  return -1;
 fail:
  result = -1;
  return result;
}

ssize_t
proto_egl85_messages_parse(proto_egl85_messages_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = proto_egl85_messages_new();
  if (NULL == *output)
    return -1;
  result = proto_egl85_messages_parse_into(*output, input, len_in);
  if (result < 0) {
    proto_egl85_messages_free(*output);
    *output = NULL;
  }
  return result;
}
domain_control_t *
domain_control_new(void)
{
  domain_control_t *val = (domain_control_t *) trunnel_calloc(1, sizeof(domain_control_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
domain_control_clear(domain_control_t *obj)
{
  (void) obj;
  control_fatality_free(obj->task_info_final_countdown);
  obj->task_info_final_countdown = NULL;
  control_xfer_protocol_free(obj->task_info_setproto);
  obj->task_info_setproto = NULL;
  control_serial_free(obj->task_info_setipcserial);
  obj->task_info_setipcserial = NULL;
  control_comm_method_free(obj->task_info_setcommmeth);
  obj->task_info_setcommmeth = NULL;
  control_xfer_protocol_free(obj->task_info_getproto);
  obj->task_info_getproto = NULL;
  control_serial_free(obj->task_info_getipcserial);
  obj->task_info_getipcserial = NULL;
  control_comm_method_free(obj->task_info_getcommmeth);
  obj->task_info_getcommmeth = NULL;
}

void
domain_control_free(domain_control_t *obj)
{
  if (obj == NULL)
    return;
  domain_control_clear(obj);
  trunnel_memwipe(obj, sizeof(domain_control_t));
  trunnel_free_(obj);
}

uint8_t
domain_control_get_task(domain_control_t *inp)
{
  return inp->task;
}
int
domain_control_set_task(domain_control_t *inp, uint8_t val)
{
  inp->task = val;
  return 0;
}
uint16_t
domain_control_get_tasklen(domain_control_t *inp)
{
  return inp->tasklen;
}
int
domain_control_set_tasklen(domain_control_t *inp, uint16_t val)
{
  inp->tasklen = val;
  return 0;
}
struct control_fatality_st *
domain_control_get_task_info_final_countdown(domain_control_t *inp)
{
  return inp->task_info_final_countdown;
}
int
domain_control_set_task_info_final_countdown(domain_control_t *inp, struct control_fatality_st *val)
{
  if (inp->task_info_final_countdown && inp->task_info_final_countdown != val)
    control_fatality_free(inp->task_info_final_countdown);
  return domain_control_set0_task_info_final_countdown(inp, val);
}
int
domain_control_set0_task_info_final_countdown(domain_control_t *inp, struct control_fatality_st *val)
{
  inp->task_info_final_countdown = val;
  return 0;
}
struct control_xfer_protocol_st *
domain_control_get_task_info_setproto(domain_control_t *inp)
{
  return inp->task_info_setproto;
}
int
domain_control_set_task_info_setproto(domain_control_t *inp, struct control_xfer_protocol_st *val)
{
  if (inp->task_info_setproto && inp->task_info_setproto != val)
    control_xfer_protocol_free(inp->task_info_setproto);
  return domain_control_set0_task_info_setproto(inp, val);
}
int
domain_control_set0_task_info_setproto(domain_control_t *inp, struct control_xfer_protocol_st *val)
{
  inp->task_info_setproto = val;
  return 0;
}
struct control_serial_st *
domain_control_get_task_info_setipcserial(domain_control_t *inp)
{
  return inp->task_info_setipcserial;
}
int
domain_control_set_task_info_setipcserial(domain_control_t *inp, struct control_serial_st *val)
{
  if (inp->task_info_setipcserial && inp->task_info_setipcserial != val)
    control_serial_free(inp->task_info_setipcserial);
  return domain_control_set0_task_info_setipcserial(inp, val);
}
int
domain_control_set0_task_info_setipcserial(domain_control_t *inp, struct control_serial_st *val)
{
  inp->task_info_setipcserial = val;
  return 0;
}
struct control_comm_method_st *
domain_control_get_task_info_setcommmeth(domain_control_t *inp)
{
  return inp->task_info_setcommmeth;
}
int
domain_control_set_task_info_setcommmeth(domain_control_t *inp, struct control_comm_method_st *val)
{
  if (inp->task_info_setcommmeth && inp->task_info_setcommmeth != val)
    control_comm_method_free(inp->task_info_setcommmeth);
  return domain_control_set0_task_info_setcommmeth(inp, val);
}
int
domain_control_set0_task_info_setcommmeth(domain_control_t *inp, struct control_comm_method_st *val)
{
  inp->task_info_setcommmeth = val;
  return 0;
}
struct control_xfer_protocol_st *
domain_control_get_task_info_getproto(domain_control_t *inp)
{
  return inp->task_info_getproto;
}
int
domain_control_set_task_info_getproto(domain_control_t *inp, struct control_xfer_protocol_st *val)
{
  if (inp->task_info_getproto && inp->task_info_getproto != val)
    control_xfer_protocol_free(inp->task_info_getproto);
  return domain_control_set0_task_info_getproto(inp, val);
}
int
domain_control_set0_task_info_getproto(domain_control_t *inp, struct control_xfer_protocol_st *val)
{
  inp->task_info_getproto = val;
  return 0;
}
struct control_serial_st *
domain_control_get_task_info_getipcserial(domain_control_t *inp)
{
  return inp->task_info_getipcserial;
}
int
domain_control_set_task_info_getipcserial(domain_control_t *inp, struct control_serial_st *val)
{
  if (inp->task_info_getipcserial && inp->task_info_getipcserial != val)
    control_serial_free(inp->task_info_getipcserial);
  return domain_control_set0_task_info_getipcserial(inp, val);
}
int
domain_control_set0_task_info_getipcserial(domain_control_t *inp, struct control_serial_st *val)
{
  inp->task_info_getipcserial = val;
  return 0;
}
struct control_comm_method_st *
domain_control_get_task_info_getcommmeth(domain_control_t *inp)
{
  return inp->task_info_getcommmeth;
}
int
domain_control_set_task_info_getcommmeth(domain_control_t *inp, struct control_comm_method_st *val)
{
  if (inp->task_info_getcommmeth && inp->task_info_getcommmeth != val)
    control_comm_method_free(inp->task_info_getcommmeth);
  return domain_control_set0_task_info_getcommmeth(inp, val);
}
int
domain_control_set0_task_info_getcommmeth(domain_control_t *inp, struct control_comm_method_st *val)
{
  inp->task_info_getcommmeth = val;
  return 0;
}
const char *
domain_control_check(const domain_control_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  switch (obj->task) {

    case CONTROL_FATALITY:
      {
        const char *msg;
        if (NULL != (msg = control_fatality_check(obj->task_info_final_countdown)))
          return msg;
      }
      break;

    case CONTROL_SET_XFER_PROTO:
      {
        const char *msg;
        if (NULL != (msg = control_xfer_protocol_check(obj->task_info_setproto)))
          return msg;
      }
      break;

    case CONTROL_SET_IPC_SERIAL:
      {
        const char *msg;
        if (NULL != (msg = control_serial_check(obj->task_info_setipcserial)))
          return msg;
      }
      break;

    case CONTROL_SET_COMM_METH:
      {
        const char *msg;
        if (NULL != (msg = control_comm_method_check(obj->task_info_setcommmeth)))
          return msg;
      }
      break;

    case CONTROL_GET_XFER_PROTO:
      {
        const char *msg;
        if (NULL != (msg = control_xfer_protocol_check(obj->task_info_getproto)))
          return msg;
      }
      break;

    case CONTROL_GET_IPC_SERIAL:
      {
        const char *msg;
        if (NULL != (msg = control_serial_check(obj->task_info_getipcserial)))
          return msg;
      }
      break;

    case CONTROL_GET_COMM_METH:
      {
        const char *msg;
        if (NULL != (msg = control_comm_method_check(obj->task_info_getcommmeth)))
          return msg;
      }
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
domain_control_encoded_len(const domain_control_t *obj)
{
  ssize_t result = 0;

  if (NULL != domain_control_check(obj))
     return -1;


  /* Length of u8 task */
  result += 1;

  /* Length of u16 tasklen */
  result += 2;
  switch (obj->task) {

    case CONTROL_FATALITY:

      /* Length of struct control_fatality task_info_final_countdown */
      result += control_fatality_encoded_len(obj->task_info_final_countdown);
      break;

    case CONTROL_SET_XFER_PROTO:

      /* Length of struct control_xfer_protocol task_info_setproto */
      result += control_xfer_protocol_encoded_len(obj->task_info_setproto);
      break;

    case CONTROL_SET_IPC_SERIAL:

      /* Length of struct control_serial task_info_setipcserial */
      result += control_serial_encoded_len(obj->task_info_setipcserial);
      break;

    case CONTROL_SET_COMM_METH:

      /* Length of struct control_comm_method task_info_setcommmeth */
      result += control_comm_method_encoded_len(obj->task_info_setcommmeth);
      break;

    case CONTROL_GET_XFER_PROTO:

      /* Length of struct control_xfer_protocol task_info_getproto */
      result += control_xfer_protocol_encoded_len(obj->task_info_getproto);
      break;

    case CONTROL_GET_IPC_SERIAL:

      /* Length of struct control_serial task_info_getipcserial */
      result += control_serial_encoded_len(obj->task_info_getipcserial);
      break;

    case CONTROL_GET_COMM_METH:

      /* Length of struct control_comm_method task_info_getcommmeth */
      result += control_comm_method_encoded_len(obj->task_info_getcommmeth);
      break;

    default:
      trunnel_assert(0);
      break;
  }
  return result;
}
int
domain_control_clear_errors(domain_control_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
domain_control_encode(uint8_t *output, const size_t avail, const domain_control_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = domain_control_encoded_len(obj);
#endif

  if (NULL != (msg = domain_control_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 task */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->task));
  written += 1; ptr += 1;

  /* Encode u16 tasklen */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->tasklen));
  written += 2; ptr += 2;

  /* Encode union task_info[task] */
  trunnel_assert(written <= avail);
  switch (obj->task) {

    case CONTROL_FATALITY:

      /* Encode struct control_fatality task_info_final_countdown */
      trunnel_assert(written <= avail);
      result = control_fatality_encode(ptr, avail - written, obj->task_info_final_countdown);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case CONTROL_SET_XFER_PROTO:

      /* Encode struct control_xfer_protocol task_info_setproto */
      trunnel_assert(written <= avail);
      result = control_xfer_protocol_encode(ptr, avail - written, obj->task_info_setproto);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case CONTROL_SET_IPC_SERIAL:

      /* Encode struct control_serial task_info_setipcserial */
      trunnel_assert(written <= avail);
      result = control_serial_encode(ptr, avail - written, obj->task_info_setipcserial);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case CONTROL_SET_COMM_METH:

      /* Encode struct control_comm_method task_info_setcommmeth */
      trunnel_assert(written <= avail);
      result = control_comm_method_encode(ptr, avail - written, obj->task_info_setcommmeth);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case CONTROL_GET_XFER_PROTO:

      /* Encode struct control_xfer_protocol task_info_getproto */
      trunnel_assert(written <= avail);
      result = control_xfer_protocol_encode(ptr, avail - written, obj->task_info_getproto);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case CONTROL_GET_IPC_SERIAL:

      /* Encode struct control_serial task_info_getipcserial */
      trunnel_assert(written <= avail);
      result = control_serial_encode(ptr, avail - written, obj->task_info_getipcserial);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case CONTROL_GET_COMM_METH:

      /* Encode struct control_comm_method task_info_getcommmeth */
      trunnel_assert(written <= avail);
      result = control_comm_method_encode(ptr, avail - written, obj->task_info_getcommmeth);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    default:
      trunnel_assert(0);
      break;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As domain_control_parse(), but do not allocate the output object.
 */
static ssize_t
domain_control_parse_into(domain_control_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 task */
  CHECK_REMAINING(1, truncated);
  obj->task = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u16 tasklen */
  CHECK_REMAINING(2, truncated);
  obj->tasklen = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse union task_info[task] */
  switch (obj->task) {

    case CONTROL_FATALITY:

      /* Parse struct control_fatality task_info_final_countdown */
      result = control_fatality_parse(&obj->task_info_final_countdown, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case CONTROL_SET_XFER_PROTO:

      /* Parse struct control_xfer_protocol task_info_setproto */
      result = control_xfer_protocol_parse(&obj->task_info_setproto, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case CONTROL_SET_IPC_SERIAL:

      /* Parse struct control_serial task_info_setipcserial */
      result = control_serial_parse(&obj->task_info_setipcserial, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case CONTROL_SET_COMM_METH:

      /* Parse struct control_comm_method task_info_setcommmeth */
      result = control_comm_method_parse(&obj->task_info_setcommmeth, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case CONTROL_GET_XFER_PROTO:

      /* Parse struct control_xfer_protocol task_info_getproto */
      result = control_xfer_protocol_parse(&obj->task_info_getproto, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case CONTROL_GET_IPC_SERIAL:

      /* Parse struct control_serial task_info_getipcserial */
      result = control_serial_parse(&obj->task_info_getipcserial, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case CONTROL_GET_COMM_METH:

      /* Parse struct control_comm_method task_info_getcommmeth */
      result = control_comm_method_parse(&obj->task_info_getcommmeth, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    default:
      goto fail;
      break;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 fail:
  result = -1;
  return result;
}

ssize_t
domain_control_parse(domain_control_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = domain_control_new();
  if (NULL == *output)
    return -1;
  result = domain_control_parse_into(*output, input, len_in);
  if (result < 0) {
    domain_control_free(*output);
    *output = NULL;
  }
  return result;
}
proto_egl85_t *
proto_egl85_new(void)
{
  proto_egl85_t *val = (proto_egl85_t *) trunnel_calloc(1, sizeof(proto_egl85_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
proto_egl85_clear(proto_egl85_t *obj)
{
  (void) obj;
  proto_egl85_messages_free(obj->tasks_msgs);
  obj->tasks_msgs = NULL;
}

void
proto_egl85_free(proto_egl85_t *obj)
{
  if (obj == NULL)
    return;
  proto_egl85_clear(obj);
  trunnel_memwipe(obj, sizeof(proto_egl85_t));
  trunnel_free_(obj);
}

uint8_t
proto_egl85_get_task(proto_egl85_t *inp)
{
  return inp->task;
}
int
proto_egl85_set_task(proto_egl85_t *inp, uint8_t val)
{
  inp->task = val;
  return 0;
}
uint8_t
proto_egl85_get_tasks_player(proto_egl85_t *inp)
{
  return inp->tasks_player;
}
int
proto_egl85_set_tasks_player(proto_egl85_t *inp, uint8_t val)
{
  if (! ((val == PROTO_PLAYER0 || val == PROTO_PLAYER1))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->tasks_player = val;
  return 0;
}
struct proto_egl85_messages_st *
proto_egl85_get_tasks_msgs(proto_egl85_t *inp)
{
  return inp->tasks_msgs;
}
int
proto_egl85_set_tasks_msgs(proto_egl85_t *inp, struct proto_egl85_messages_st *val)
{
  if (inp->tasks_msgs && inp->tasks_msgs != val)
    proto_egl85_messages_free(inp->tasks_msgs);
  return proto_egl85_set0_tasks_msgs(inp, val);
}
int
proto_egl85_set0_tasks_msgs(proto_egl85_t *inp, struct proto_egl85_messages_st *val)
{
  inp->tasks_msgs = val;
  return 0;
}
uint8_t
proto_egl85_get_tasks_selection(proto_egl85_t *inp)
{
  return inp->tasks_selection;
}
int
proto_egl85_set_tasks_selection(proto_egl85_t *inp, uint8_t val)
{
  inp->tasks_selection = val;
  return 0;
}
const char *
proto_egl85_check(const proto_egl85_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  switch (obj->task) {

    case PROTOCOL_SETPLAYER:
      if (! (obj->tasks_player == PROTO_PLAYER0 || obj->tasks_player == PROTO_PLAYER1))
        return "Integer out of bounds";
      break;

    case PROTOCOL_SETMESSAGES:
      {
        const char *msg;
        if (NULL != (msg = proto_egl85_messages_check(obj->tasks_msgs)))
          return msg;
      }
      break;

    case PROTOCOL_SETSELECTION:
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
proto_egl85_encoded_len(const proto_egl85_t *obj)
{
  ssize_t result = 0;

  if (NULL != proto_egl85_check(obj))
     return -1;


  /* Length of u8 task */
  result += 1;
  switch (obj->task) {

    case PROTOCOL_SETPLAYER:

      /* Length of u8 tasks_player IN [PROTO_PLAYER0, PROTO_PLAYER1] */
      result += 1;
      break;

    case PROTOCOL_SETMESSAGES:

      /* Length of struct proto_egl85_messages tasks_msgs */
      result += proto_egl85_messages_encoded_len(obj->tasks_msgs);
      break;

    case PROTOCOL_SETSELECTION:

      /* Length of u8 tasks_selection */
      result += 1;
      break;

    default:
      trunnel_assert(0);
      break;
  }
  return result;
}
int
proto_egl85_clear_errors(proto_egl85_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
proto_egl85_encode(uint8_t *output, const size_t avail, const proto_egl85_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = proto_egl85_encoded_len(obj);
#endif

  if (NULL != (msg = proto_egl85_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 task */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->task));
  written += 1; ptr += 1;

  /* Encode union tasks[task] */
  trunnel_assert(written <= avail);
  switch (obj->task) {

    case PROTOCOL_SETPLAYER:

      /* Encode u8 tasks_player IN [PROTO_PLAYER0, PROTO_PLAYER1] */
      trunnel_assert(written <= avail);
      if (avail - written < 1)
        goto truncated;
      trunnel_set_uint8(ptr, (obj->tasks_player));
      written += 1; ptr += 1;
      break;

    case PROTOCOL_SETMESSAGES:

      /* Encode struct proto_egl85_messages tasks_msgs */
      trunnel_assert(written <= avail);
      result = proto_egl85_messages_encode(ptr, avail - written, obj->tasks_msgs);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case PROTOCOL_SETSELECTION:

      /* Encode u8 tasks_selection */
      trunnel_assert(written <= avail);
      if (avail - written < 1)
        goto truncated;
      trunnel_set_uint8(ptr, (obj->tasks_selection));
      written += 1; ptr += 1;
      break;

    default:
      trunnel_assert(0);
      break;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As proto_egl85_parse(), but do not allocate the output object.
 */
static ssize_t
proto_egl85_parse_into(proto_egl85_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 task */
  CHECK_REMAINING(1, truncated);
  obj->task = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse union tasks[task] */
  switch (obj->task) {

    case PROTOCOL_SETPLAYER:

      /* Parse u8 tasks_player IN [PROTO_PLAYER0, PROTO_PLAYER1] */
      CHECK_REMAINING(1, truncated);
      obj->tasks_player = (trunnel_get_uint8(ptr));
      remaining -= 1; ptr += 1;
      if (! (obj->tasks_player == PROTO_PLAYER0 || obj->tasks_player == PROTO_PLAYER1))
        goto fail;
      break;

    case PROTOCOL_SETMESSAGES:

      /* Parse struct proto_egl85_messages tasks_msgs */
      result = proto_egl85_messages_parse(&obj->tasks_msgs, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case PROTOCOL_SETSELECTION:

      /* Parse u8 tasks_selection */
      CHECK_REMAINING(1, truncated);
      obj->tasks_selection = (trunnel_get_uint8(ptr));
      remaining -= 1; ptr += 1;
      break;

    default:
      goto fail;
      break;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 fail:
  result = -1;
  return result;
}

ssize_t
proto_egl85_parse(proto_egl85_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = proto_egl85_new();
  if (NULL == *output)
    return -1;
  result = proto_egl85_parse_into(*output, input, len_in);
  if (result < 0) {
    proto_egl85_free(*output);
    *output = NULL;
  }
  return result;
}
domain_protocol_t *
domain_protocol_new(void)
{
  domain_protocol_t *val = (domain_protocol_t *) trunnel_calloc(1, sizeof(domain_protocol_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
domain_protocol_clear(domain_protocol_t *obj)
{
  (void) obj;
  proto_egl85_free(obj->proto_egl85);
  obj->proto_egl85 = NULL;
}

void
domain_protocol_free(domain_protocol_t *obj)
{
  if (obj == NULL)
    return;
  domain_protocol_clear(obj);
  trunnel_memwipe(obj, sizeof(domain_protocol_t));
  trunnel_free_(obj);
}

uint8_t
domain_protocol_get_name(domain_protocol_t *inp)
{
  return inp->name;
}
int
domain_protocol_set_name(domain_protocol_t *inp, uint8_t val)
{
  inp->name = val;
  return 0;
}
struct proto_egl85_st *
domain_protocol_get_proto_egl85(domain_protocol_t *inp)
{
  return inp->proto_egl85;
}
int
domain_protocol_set_proto_egl85(domain_protocol_t *inp, struct proto_egl85_st *val)
{
  if (inp->proto_egl85 && inp->proto_egl85 != val)
    proto_egl85_free(inp->proto_egl85);
  return domain_protocol_set0_proto_egl85(inp, val);
}
int
domain_protocol_set0_proto_egl85(domain_protocol_t *inp, struct proto_egl85_st *val)
{
  inp->proto_egl85 = val;
  return 0;
}
const char *
domain_protocol_check(const domain_protocol_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  switch (obj->name) {

    case XFERPROTO_EGL85:
      {
        const char *msg;
        if (NULL != (msg = proto_egl85_check(obj->proto_egl85)))
          return msg;
      }
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
domain_protocol_encoded_len(const domain_protocol_t *obj)
{
  ssize_t result = 0;

  if (NULL != domain_protocol_check(obj))
     return -1;


  /* Length of u8 name */
  result += 1;
  switch (obj->name) {

    case XFERPROTO_EGL85:

      /* Length of struct proto_egl85 proto_egl85 */
      result += proto_egl85_encoded_len(obj->proto_egl85);
      break;

    default:
      trunnel_assert(0);
      break;
  }
  return result;
}
int
domain_protocol_clear_errors(domain_protocol_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
domain_protocol_encode(uint8_t *output, const size_t avail, const domain_protocol_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = domain_protocol_encoded_len(obj);
#endif

  if (NULL != (msg = domain_protocol_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 name */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->name));
  written += 1; ptr += 1;

  /* Encode union proto[name] */
  trunnel_assert(written <= avail);
  switch (obj->name) {

    case XFERPROTO_EGL85:

      /* Encode struct proto_egl85 proto_egl85 */
      trunnel_assert(written <= avail);
      result = proto_egl85_encode(ptr, avail - written, obj->proto_egl85);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    default:
      trunnel_assert(0);
      break;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As domain_protocol_parse(), but do not allocate the output object.
 */
static ssize_t
domain_protocol_parse_into(domain_protocol_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 name */
  CHECK_REMAINING(1, truncated);
  obj->name = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse union proto[name] */
  switch (obj->name) {

    case XFERPROTO_EGL85:

      /* Parse struct proto_egl85 proto_egl85 */
      result = proto_egl85_parse(&obj->proto_egl85, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    default:
      goto fail;
      break;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 fail:
  result = -1;
  return result;
}

ssize_t
domain_protocol_parse(domain_protocol_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = domain_protocol_new();
  if (NULL == *output)
    return -1;
  result = domain_protocol_parse_into(*output, input, len_in);
  if (result < 0) {
    domain_protocol_free(*output);
    *output = NULL;
  }
  return result;
}
domain_base_t *
domain_base_new(void)
{
  domain_base_t *val = (domain_base_t *) trunnel_calloc(1, sizeof(domain_base_t));
  if (NULL == val)
    return NULL;
  val->message_domain = DOMAIN_CONTROL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
domain_base_clear(domain_base_t *obj)
{
  (void) obj;
  domain_control_free(obj->domain_message_domcon);
  obj->domain_message_domcon = NULL;
  domain_protocol_free(obj->domain_message_domproto);
  obj->domain_message_domproto = NULL;
  domain_status_free(obj->domain_message_domstat);
  obj->domain_message_domstat = NULL;
}

void
domain_base_free(domain_base_t *obj)
{
  if (obj == NULL)
    return;
  domain_base_clear(obj);
  trunnel_memwipe(obj, sizeof(domain_base_t));
  trunnel_free_(obj);
}

uint8_t
domain_base_get_version(domain_base_t *inp)
{
  return inp->version;
}
int
domain_base_set_version(domain_base_t *inp, uint8_t val)
{
  if (! ((val == 0))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->version = val;
  return 0;
}
uint32_t
domain_base_get_length(domain_base_t *inp)
{
  return inp->length;
}
int
domain_base_set_length(domain_base_t *inp, uint32_t val)
{
  inp->length = val;
  return 0;
}
uint8_t
domain_base_get_message_domain(domain_base_t *inp)
{
  return inp->message_domain;
}
int
domain_base_set_message_domain(domain_base_t *inp, uint8_t val)
{
  if (! ((val == DOMAIN_CONTROL || val == DOMAIN_NOT_DEFINED || val == DOMAIN_PROTOCOL || val == DOMAIN_STATUS))) {
     TRUNNEL_SET_ERROR_CODE(inp);
     return -1;
  }
  inp->message_domain = val;
  return 0;
}
struct domain_control_st *
domain_base_get_domain_message_domcon(domain_base_t *inp)
{
  return inp->domain_message_domcon;
}
int
domain_base_set_domain_message_domcon(domain_base_t *inp, struct domain_control_st *val)
{
  if (inp->domain_message_domcon && inp->domain_message_domcon != val)
    domain_control_free(inp->domain_message_domcon);
  return domain_base_set0_domain_message_domcon(inp, val);
}
int
domain_base_set0_domain_message_domcon(domain_base_t *inp, struct domain_control_st *val)
{
  inp->domain_message_domcon = val;
  return 0;
}
struct domain_protocol_st *
domain_base_get_domain_message_domproto(domain_base_t *inp)
{
  return inp->domain_message_domproto;
}
int
domain_base_set_domain_message_domproto(domain_base_t *inp, struct domain_protocol_st *val)
{
  if (inp->domain_message_domproto && inp->domain_message_domproto != val)
    domain_protocol_free(inp->domain_message_domproto);
  return domain_base_set0_domain_message_domproto(inp, val);
}
int
domain_base_set0_domain_message_domproto(domain_base_t *inp, struct domain_protocol_st *val)
{
  inp->domain_message_domproto = val;
  return 0;
}
struct domain_status_st *
domain_base_get_domain_message_domstat(domain_base_t *inp)
{
  return inp->domain_message_domstat;
}
int
domain_base_set_domain_message_domstat(domain_base_t *inp, struct domain_status_st *val)
{
  if (inp->domain_message_domstat && inp->domain_message_domstat != val)
    domain_status_free(inp->domain_message_domstat);
  return domain_base_set0_domain_message_domstat(inp, val);
}
int
domain_base_set0_domain_message_domstat(domain_base_t *inp, struct domain_status_st *val)
{
  inp->domain_message_domstat = val;
  return 0;
}
const char *
domain_base_check(const domain_base_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (! (obj->version == 0))
    return "Integer out of bounds";
  if (! (obj->message_domain == DOMAIN_CONTROL || obj->message_domain == DOMAIN_NOT_DEFINED || obj->message_domain == DOMAIN_PROTOCOL || obj->message_domain == DOMAIN_STATUS))
    return "Integer out of bounds";
  switch (obj->message_domain) {

    case DOMAIN_NOT_DEFINED:
        return "Bad tag for union";
      break;

    case DOMAIN_CONTROL:
      {
        const char *msg;
        if (NULL != (msg = domain_control_check(obj->domain_message_domcon)))
          return msg;
      }
      break;

    case DOMAIN_PROTOCOL:
      {
        const char *msg;
        if (NULL != (msg = domain_protocol_check(obj->domain_message_domproto)))
          return msg;
      }
      break;

    case DOMAIN_STATUS:
      {
        const char *msg;
        if (NULL != (msg = domain_status_check(obj->domain_message_domstat)))
          return msg;
      }
      break;

    default:
        return "Bad tag for union";
      break;
  }
  return NULL;
}

ssize_t
domain_base_encoded_len(const domain_base_t *obj)
{
  ssize_t result = 0;

  if (NULL != domain_base_check(obj))
     return -1;


  /* Length of u8 version IN [0] */
  result += 1;

  /* Length of u32 length */
  result += 4;

  /* Length of u8 message_domain IN [DOMAIN_CONTROL, DOMAIN_NOT_DEFINED, DOMAIN_PROTOCOL, DOMAIN_STATUS] */
  result += 1;
  switch (obj->message_domain) {

    case DOMAIN_NOT_DEFINED:
      trunnel_assert(0);
      break;

    case DOMAIN_CONTROL:

      /* Length of struct domain_control domain_message_domcon */
      result += domain_control_encoded_len(obj->domain_message_domcon);
      break;

    case DOMAIN_PROTOCOL:

      /* Length of struct domain_protocol domain_message_domproto */
      result += domain_protocol_encoded_len(obj->domain_message_domproto);
      break;

    case DOMAIN_STATUS:

      /* Length of struct domain_status domain_message_domstat */
      result += domain_status_encoded_len(obj->domain_message_domstat);
      break;

    default:
      trunnel_assert(0);
      break;
  }
  return result;
}
int
domain_base_clear_errors(domain_base_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
domain_base_encode(uint8_t *output, const size_t avail, const domain_base_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = domain_base_encoded_len(obj);
#endif

  if (NULL != (msg = domain_base_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 version IN [0] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->version));
  written += 1; ptr += 1;

  /* Encode u32 length */
  trunnel_assert(written <= avail);
  if (avail - written < 4)
    goto truncated;
  trunnel_set_uint32(ptr, trunnel_htonl(obj->length));
  written += 4; ptr += 4;

  /* Encode u8 message_domain IN [DOMAIN_CONTROL, DOMAIN_NOT_DEFINED, DOMAIN_PROTOCOL, DOMAIN_STATUS] */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->message_domain));
  written += 1; ptr += 1;

  /* Encode union domain_message[message_domain] */
  trunnel_assert(written <= avail);
  switch (obj->message_domain) {

    case DOMAIN_NOT_DEFINED:
      trunnel_assert(0);
      break;

    case DOMAIN_CONTROL:

      /* Encode struct domain_control domain_message_domcon */
      trunnel_assert(written <= avail);
      result = domain_control_encode(ptr, avail - written, obj->domain_message_domcon);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case DOMAIN_PROTOCOL:

      /* Encode struct domain_protocol domain_message_domproto */
      trunnel_assert(written <= avail);
      result = domain_protocol_encode(ptr, avail - written, obj->domain_message_domproto);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    case DOMAIN_STATUS:

      /* Encode struct domain_status domain_message_domstat */
      trunnel_assert(written <= avail);
      result = domain_status_encode(ptr, avail - written, obj->domain_message_domstat);
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
      break;

    default:
      trunnel_assert(0);
      break;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As domain_base_parse(), but do not allocate the output object.
 */
static ssize_t
domain_base_parse_into(domain_base_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 version IN [0] */
  CHECK_REMAINING(1, truncated);
  obj->version = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->version == 0))
    goto fail;

  /* Parse u32 length */
  CHECK_REMAINING(4, truncated);
  obj->length = trunnel_ntohl(trunnel_get_uint32(ptr));
  remaining -= 4; ptr += 4;

  /* Parse u8 message_domain IN [DOMAIN_CONTROL, DOMAIN_NOT_DEFINED, DOMAIN_PROTOCOL, DOMAIN_STATUS] */
  CHECK_REMAINING(1, truncated);
  obj->message_domain = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;
  if (! (obj->message_domain == DOMAIN_CONTROL || obj->message_domain == DOMAIN_NOT_DEFINED || obj->message_domain == DOMAIN_PROTOCOL || obj->message_domain == DOMAIN_STATUS))
    goto fail;

  /* Parse union domain_message[message_domain] */
  switch (obj->message_domain) {

    case DOMAIN_NOT_DEFINED:
      goto fail;
      break;

    case DOMAIN_CONTROL:

      /* Parse struct domain_control domain_message_domcon */
      result = domain_control_parse(&obj->domain_message_domcon, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case DOMAIN_PROTOCOL:

      /* Parse struct domain_protocol domain_message_domproto */
      result = domain_protocol_parse(&obj->domain_message_domproto, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    case DOMAIN_STATUS:

      /* Parse struct domain_status domain_message_domstat */
      result = domain_status_parse(&obj->domain_message_domstat, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      break;

    default:
      goto fail;
      break;
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 fail:
  result = -1;
  return result;
}

ssize_t
domain_base_parse(domain_base_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = domain_base_new();
  if (NULL == *output)
    return -1;
  result = domain_base_parse_into(*output, input, len_in);
  if (result < 0) {
    domain_base_free(*output);
    *output = NULL;
  }
  return result;
}
