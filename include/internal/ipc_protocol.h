/* ipc_protocol.h -- generated by by Trunnel v1.4.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_IPC_PROTOCOL_H
#define TRUNNEL_IPC_PROTOCOL_H

#include <stdint.h>
#include "trunnel.h"

#define DOMAIN_NOT_DEFINED 0
#define DOMAIN_CONTROL 1
#define DOMAIN_PROTOCOL 2
#define DOMAIN_STATUS 4
#define CONTROL_FATALITY 0
#define CONTROL_SET_XFER_PROTO 1
#define CONTROL_SET_IPC_SERIAL 2
#define CONTROL_SET_COMM_METH 4
#define CONTROL_GET_XFER_PROTO 8
#define CONTROL_GET_IPC_SERIAL 16
#define CONTROL_GET_COMM_METH 32
#define FATALITY_IMMEDIATE 0
#define FATALITY_ASAP 1
#define XFERPROTO_EGL85 0
#define SERIAL_BUILTIN 0
#define COMM_DEV_FILEDESCR 0
#define COMM_DEV_CALLBACK 1
#define COMM_DEV_INTERNAL 2
#define PROTOCOL_SETPLAYER 0
#define PROTOCOL_SETMESSAGES 1
#define PROTOCOL_SETSELECTION 2
#define PROTO_PLAYER0 0
#define PROTO_PLAYER1 1
#define VERBOSITY_ERROR 0
#define VERBOSITY_WARNING 1
#define VERBOSITY_NOTICE 2
#define VERBOSITY_INFO 4
#define VERBOSITY_DEBUG 8
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_CONTROL_COMM_METHOD)
struct control_comm_method_st {
  uint8_t device;
  uint16_t method_fd;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct control_comm_method_st control_comm_method_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_CONTROL_FATALITY)
struct control_fatality_st {
  uint8_t fatality_time;
  char *message;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct control_fatality_st control_fatality_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_CONTROL_SERIAL)
struct control_serial_st {
  uint8_t serialization;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct control_serial_st control_serial_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_CONTROL_XFER_PROTOCOL)
struct control_xfer_protocol_st {
  uint8_t proto;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct control_xfer_protocol_st control_xfer_protocol_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_DOMAIN_STATUS)
struct domain_status_st {
  uint8_t verbosity;
  uint16_t msglen;
  char *msg;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct domain_status_st domain_status_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_PROTO_EGL85_MESSAGES)
struct proto_egl85_messages_st {
  uint32_t msgslen;
  uint8_t msgcount;
  TRUNNEL_DYNARRAY_HEAD(, uint32_t) msglens;
  trunnel_string_t msgs;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct proto_egl85_messages_st proto_egl85_messages_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_DOMAIN_CONTROL)
struct domain_control_st {
  uint8_t task;
  uint16_t tasklen;
  struct control_fatality_st *task_info_final_countdown;
  struct control_xfer_protocol_st *task_info_setproto;
  struct control_serial_st *task_info_setipcserial;
  struct control_comm_method_st *task_info_setcommmeth;
  struct control_xfer_protocol_st *task_info_getproto;
  struct control_serial_st *task_info_getipcserial;
  struct control_comm_method_st *task_info_getcommmeth;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct domain_control_st domain_control_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_PROTO_EGL85)
struct proto_egl85_st {
  uint8_t task;
  uint8_t tasks_player;
  struct proto_egl85_messages_st *tasks_msgs;
  uint8_t tasks_selection;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct proto_egl85_st proto_egl85_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_DOMAIN_PROTOCOL)
struct domain_protocol_st {
  uint8_t name;
  struct proto_egl85_st *proto_egl85;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct domain_protocol_st domain_protocol_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_DOMAIN_BASE)
struct domain_base_st {
  uint8_t version;
  uint32_t length;
  uint8_t message_domain;
  struct domain_control_st *domain_message_domcon;
  struct domain_protocol_st *domain_message_domproto;
  struct domain_status_st *domain_message_domstat;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct domain_base_st domain_base_t;
/** Return a newly allocated control_comm_method with all elements set
 * to zero.
 */
control_comm_method_t *control_comm_method_new(void);
/** Release all storage held by the control_comm_method in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void control_comm_method_free(control_comm_method_t *victim);
/** Try to parse a control_comm_method from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated control_comm_method_t. On failure, return -2 if the input
 * appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t control_comm_method_parse(control_comm_method_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * control_comm_method in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t control_comm_method_encoded_len(const control_comm_method_t *obj);
/** Try to encode the control_comm_method from 'input' into the buffer
 * at 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t control_comm_method_encode(uint8_t *output, size_t avail, const control_comm_method_t *input);
/** Check whether the internal state of the control_comm_method in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *control_comm_method_check(const control_comm_method_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int control_comm_method_clear_errors(control_comm_method_t *obj);
/** Return the value of the device field of the control_comm_method_t
 * in 'inp'
 */
uint8_t control_comm_method_get_device(control_comm_method_t *inp);
/** Set the value of the device field of the control_comm_method_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int control_comm_method_set_device(control_comm_method_t *inp, uint8_t val);
/** Return the value of the method_fd field of the
 * control_comm_method_t in 'inp'
 */
uint16_t control_comm_method_get_method_fd(control_comm_method_t *inp);
/** Set the value of the method_fd field of the control_comm_method_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int control_comm_method_set_method_fd(control_comm_method_t *inp, uint16_t val);
/** Return a newly allocated control_fatality with all elements set to
 * zero.
 */
control_fatality_t *control_fatality_new(void);
/** Release all storage held by the control_fatality in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void control_fatality_free(control_fatality_t *victim);
/** Try to parse a control_fatality from the buffer in 'input', using
 * up to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * control_fatality_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t control_fatality_parse(control_fatality_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * control_fatality in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t control_fatality_encoded_len(const control_fatality_t *obj);
/** Try to encode the control_fatality from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t control_fatality_encode(uint8_t *output, size_t avail, const control_fatality_t *input);
/** Check whether the internal state of the control_fatality in 'obj'
 * is consistent. Return NULL if it is, and a short message if it is
 * not.
 */
const char *control_fatality_check(const control_fatality_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int control_fatality_clear_errors(control_fatality_t *obj);
/** Return the value of the fatality_time field of the
 * control_fatality_t in 'inp'
 */
uint8_t control_fatality_get_fatality_time(control_fatality_t *inp);
/** Set the value of the fatality_time field of the control_fatality_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int control_fatality_set_fatality_time(control_fatality_t *inp, uint8_t val);
/** Return the value of the message field of the control_fatality_t in
 * 'inp'
 */
const char * control_fatality_get_message(control_fatality_t *inp);
/** Set the value of the message field of the control_fatality_t in
 * 'inp' to 'val'. Free the old value if any. Does not steal the
 * reference to 'val'.Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int control_fatality_set_message(control_fatality_t *inp, const char *val);
/** Return a newly allocated control_serial with all elements set to
 * zero.
 */
control_serial_t *control_serial_new(void);
/** Release all storage held by the control_serial in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void control_serial_free(control_serial_t *victim);
/** Try to parse a control_serial from the buffer in 'input', using up
 * to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * control_serial_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t control_serial_parse(control_serial_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * control_serial in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t control_serial_encoded_len(const control_serial_t *obj);
/** Try to encode the control_serial from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t control_serial_encode(uint8_t *output, size_t avail, const control_serial_t *input);
/** Check whether the internal state of the control_serial in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *control_serial_check(const control_serial_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int control_serial_clear_errors(control_serial_t *obj);
/** Return the value of the serialization field of the
 * control_serial_t in 'inp'
 */
uint8_t control_serial_get_serialization(control_serial_t *inp);
/** Set the value of the serialization field of the control_serial_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int control_serial_set_serialization(control_serial_t *inp, uint8_t val);
/** Return a newly allocated control_xfer_protocol with all elements
 * set to zero.
 */
control_xfer_protocol_t *control_xfer_protocol_new(void);
/** Release all storage held by the control_xfer_protocol in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void control_xfer_protocol_free(control_xfer_protocol_t *victim);
/** Try to parse a control_xfer_protocol from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated control_xfer_protocol_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t control_xfer_protocol_parse(control_xfer_protocol_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * control_xfer_protocol in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t control_xfer_protocol_encoded_len(const control_xfer_protocol_t *obj);
/** Try to encode the control_xfer_protocol from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t control_xfer_protocol_encode(uint8_t *output, size_t avail, const control_xfer_protocol_t *input);
/** Check whether the internal state of the control_xfer_protocol in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *control_xfer_protocol_check(const control_xfer_protocol_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int control_xfer_protocol_clear_errors(control_xfer_protocol_t *obj);
/** Return the value of the proto field of the control_xfer_protocol_t
 * in 'inp'
 */
uint8_t control_xfer_protocol_get_proto(control_xfer_protocol_t *inp);
/** Set the value of the proto field of the control_xfer_protocol_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int control_xfer_protocol_set_proto(control_xfer_protocol_t *inp, uint8_t val);
/** Return a newly allocated domain_status with all elements set to
 * zero.
 */
domain_status_t *domain_status_new(void);
/** Release all storage held by the domain_status in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void domain_status_free(domain_status_t *victim);
/** Try to parse a domain_status from the buffer in 'input', using up
 * to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * domain_status_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t domain_status_parse(domain_status_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * domain_status in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t domain_status_encoded_len(const domain_status_t *obj);
/** Try to encode the domain_status from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t domain_status_encode(uint8_t *output, size_t avail, const domain_status_t *input);
/** Check whether the internal state of the domain_status in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *domain_status_check(const domain_status_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int domain_status_clear_errors(domain_status_t *obj);
/** Return the value of the verbosity field of the domain_status_t in
 * 'inp'
 */
uint8_t domain_status_get_verbosity(domain_status_t *inp);
/** Set the value of the verbosity field of the domain_status_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int domain_status_set_verbosity(domain_status_t *inp, uint8_t val);
/** Return the value of the msglen field of the domain_status_t in
 * 'inp'
 */
uint16_t domain_status_get_msglen(domain_status_t *inp);
/** Set the value of the msglen field of the domain_status_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_status_set_msglen(domain_status_t *inp, uint16_t val);
/** Return the value of the msg field of the domain_status_t in 'inp'
 */
const char * domain_status_get_msg(domain_status_t *inp);
/** Set the value of the msg field of the domain_status_t in 'inp' to
 * 'val'. Free the old value if any. Does not steal the reference to
 * 'val'.Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_status_set_msg(domain_status_t *inp, const char *val);
/** Return a newly allocated proto_egl85_messages with all elements
 * set to zero.
 */
proto_egl85_messages_t *proto_egl85_messages_new(void);
/** Release all storage held by the proto_egl85_messages in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void proto_egl85_messages_free(proto_egl85_messages_t *victim);
/** Try to parse a proto_egl85_messages from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated proto_egl85_messages_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t proto_egl85_messages_parse(proto_egl85_messages_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * proto_egl85_messages in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t proto_egl85_messages_encoded_len(const proto_egl85_messages_t *obj);
/** Try to encode the proto_egl85_messages from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t proto_egl85_messages_encode(uint8_t *output, size_t avail, const proto_egl85_messages_t *input);
/** Check whether the internal state of the proto_egl85_messages in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *proto_egl85_messages_check(const proto_egl85_messages_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int proto_egl85_messages_clear_errors(proto_egl85_messages_t *obj);
/** Return the value of the msgslen field of the
 * proto_egl85_messages_t in 'inp'
 */
uint32_t proto_egl85_messages_get_msgslen(proto_egl85_messages_t *inp);
/** Set the value of the msgslen field of the proto_egl85_messages_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int proto_egl85_messages_set_msgslen(proto_egl85_messages_t *inp, uint32_t val);
/** Return the value of the msgcount field of the
 * proto_egl85_messages_t in 'inp'
 */
uint8_t proto_egl85_messages_get_msgcount(proto_egl85_messages_t *inp);
/** Set the value of the msgcount field of the proto_egl85_messages_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int proto_egl85_messages_set_msgcount(proto_egl85_messages_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the msglens field
 * of the proto_egl85_messages_t in 'inp'.
 */
size_t proto_egl85_messages_getlen_msglens(const proto_egl85_messages_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * msglens of the proto_egl85_messages_t in 'inp'.
 */
uint32_t proto_egl85_messages_get_msglens(proto_egl85_messages_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * msglens of the proto_egl85_messages_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int proto_egl85_messages_set_msglens(proto_egl85_messages_t *inp, size_t idx, uint32_t elt);
/** Append a new element 'elt' to the dynamic array field msglens of
 * the proto_egl85_messages_t in 'inp'.
 */
int proto_egl85_messages_add_msglens(proto_egl85_messages_t *inp, uint32_t elt);
/** Return a pointer to the variable-length array field msglens of
 * 'inp'.
 */
uint32_t * proto_egl85_messages_getarray_msglens(proto_egl85_messages_t *inp);
/** Change the length of the variable-length array field msglens of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int proto_egl85_messages_setlen_msglens(proto_egl85_messages_t *inp, size_t newlen);
/** Return the length of the dynamic array holding the msgs field of
 * the proto_egl85_messages_t in 'inp'.
 */
size_t proto_egl85_messages_getlen_msgs(const proto_egl85_messages_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * msgs of the proto_egl85_messages_t in 'inp'.
 */
char proto_egl85_messages_get_msgs(proto_egl85_messages_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * msgs of the proto_egl85_messages_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int proto_egl85_messages_set_msgs(proto_egl85_messages_t *inp, size_t idx, char elt);
/** Append a new element 'elt' to the dynamic array field msgs of the
 * proto_egl85_messages_t in 'inp'.
 */
int proto_egl85_messages_add_msgs(proto_egl85_messages_t *inp, char elt);
/** Return a pointer to the variable-length array field msgs of 'inp'.
 */
char * proto_egl85_messages_getarray_msgs(proto_egl85_messages_t *inp);
/** Change the length of the variable-length array field msgs of 'inp'
 * to 'newlen'.Fill extra elements with 0. Return 0 on success; return
 * -1 and set the error code on 'inp' on failure.
 */
int proto_egl85_messages_setlen_msgs(proto_egl85_messages_t *inp, size_t newlen);
/** Return the value of the msgs field of a proto_egl85_messages_t as
 * a NUL-terminated string.
 */
const char * proto_egl85_messages_getstr_msgs(proto_egl85_messages_t *inp);
/** Set the value of the msgs field of a proto_egl85_messages_t to a
 * given string of length 'len'. Return 0 on success; return -1 and
 * set the error code on 'inp' on failure.
 */
int proto_egl85_messages_setstr0_msgs(proto_egl85_messages_t *inp, const char *val, size_t len);
/** Set the value of the msgs field of a proto_egl85_messages_t to a
 * given NUL-terminated string. Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int proto_egl85_messages_setstr_msgs(proto_egl85_messages_t *inp, const char *val);
/** Return a newly allocated domain_control with all elements set to
 * zero.
 */
domain_control_t *domain_control_new(void);
/** Release all storage held by the domain_control in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void domain_control_free(domain_control_t *victim);
/** Try to parse a domain_control from the buffer in 'input', using up
 * to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * domain_control_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t domain_control_parse(domain_control_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * domain_control in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t domain_control_encoded_len(const domain_control_t *obj);
/** Try to encode the domain_control from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t domain_control_encode(uint8_t *output, size_t avail, const domain_control_t *input);
/** Check whether the internal state of the domain_control in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *domain_control_check(const domain_control_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int domain_control_clear_errors(domain_control_t *obj);
/** Return the value of the task field of the domain_control_t in
 * 'inp'
 */
uint8_t domain_control_get_task(domain_control_t *inp);
/** Set the value of the task field of the domain_control_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_control_set_task(domain_control_t *inp, uint8_t val);
/** Return the value of the tasklen field of the domain_control_t in
 * 'inp'
 */
uint16_t domain_control_get_tasklen(domain_control_t *inp);
/** Set the value of the tasklen field of the domain_control_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int domain_control_set_tasklen(domain_control_t *inp, uint16_t val);
/** Return the value of the task_info_final_countdown field of the
 * domain_control_t in 'inp'
 */
struct control_fatality_st * domain_control_get_task_info_final_countdown(domain_control_t *inp);
/** Set the value of the task_info_final_countdown field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_final_countdown(domain_control_t *inp, struct control_fatality_st *val);
/** As domain_control_set_task_info_final_countdown, but does not free
 * the previous value.
 */
int domain_control_set0_task_info_final_countdown(domain_control_t *inp, struct control_fatality_st *val);
/** Return the value of the task_info_setproto field of the
 * domain_control_t in 'inp'
 */
struct control_xfer_protocol_st * domain_control_get_task_info_setproto(domain_control_t *inp);
/** Set the value of the task_info_setproto field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_setproto(domain_control_t *inp, struct control_xfer_protocol_st *val);
/** As domain_control_set_task_info_setproto, but does not free the
 * previous value.
 */
int domain_control_set0_task_info_setproto(domain_control_t *inp, struct control_xfer_protocol_st *val);
/** Return the value of the task_info_setipcserial field of the
 * domain_control_t in 'inp'
 */
struct control_serial_st * domain_control_get_task_info_setipcserial(domain_control_t *inp);
/** Set the value of the task_info_setipcserial field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_setipcserial(domain_control_t *inp, struct control_serial_st *val);
/** As domain_control_set_task_info_setipcserial, but does not free
 * the previous value.
 */
int domain_control_set0_task_info_setipcserial(domain_control_t *inp, struct control_serial_st *val);
/** Return the value of the task_info_setcommmeth field of the
 * domain_control_t in 'inp'
 */
struct control_comm_method_st * domain_control_get_task_info_setcommmeth(domain_control_t *inp);
/** Set the value of the task_info_setcommmeth field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_setcommmeth(domain_control_t *inp, struct control_comm_method_st *val);
/** As domain_control_set_task_info_setcommmeth, but does not free the
 * previous value.
 */
int domain_control_set0_task_info_setcommmeth(domain_control_t *inp, struct control_comm_method_st *val);
/** Return the value of the task_info_getproto field of the
 * domain_control_t in 'inp'
 */
struct control_xfer_protocol_st * domain_control_get_task_info_getproto(domain_control_t *inp);
/** Set the value of the task_info_getproto field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_getproto(domain_control_t *inp, struct control_xfer_protocol_st *val);
/** As domain_control_set_task_info_getproto, but does not free the
 * previous value.
 */
int domain_control_set0_task_info_getproto(domain_control_t *inp, struct control_xfer_protocol_st *val);
/** Return the value of the task_info_getipcserial field of the
 * domain_control_t in 'inp'
 */
struct control_serial_st * domain_control_get_task_info_getipcserial(domain_control_t *inp);
/** Set the value of the task_info_getipcserial field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_getipcserial(domain_control_t *inp, struct control_serial_st *val);
/** As domain_control_set_task_info_getipcserial, but does not free
 * the previous value.
 */
int domain_control_set0_task_info_getipcserial(domain_control_t *inp, struct control_serial_st *val);
/** Return the value of the task_info_getcommmeth field of the
 * domain_control_t in 'inp'
 */
struct control_comm_method_st * domain_control_get_task_info_getcommmeth(domain_control_t *inp);
/** Set the value of the task_info_getcommmeth field of the
 * domain_control_t in 'inp' to 'val'. Free the old value if any.
 * Steals the referenceto 'val'.Return 0 on success; return -1 and set
 * the error code on 'inp' on failure.
 */
int domain_control_set_task_info_getcommmeth(domain_control_t *inp, struct control_comm_method_st *val);
/** As domain_control_set_task_info_getcommmeth, but does not free the
 * previous value.
 */
int domain_control_set0_task_info_getcommmeth(domain_control_t *inp, struct control_comm_method_st *val);
/** Return a newly allocated proto_egl85 with all elements set to
 * zero.
 */
proto_egl85_t *proto_egl85_new(void);
/** Release all storage held by the proto_egl85 in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void proto_egl85_free(proto_egl85_t *victim);
/** Try to parse a proto_egl85 from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * proto_egl85_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t proto_egl85_parse(proto_egl85_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * proto_egl85 in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t proto_egl85_encoded_len(const proto_egl85_t *obj);
/** Try to encode the proto_egl85 from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t proto_egl85_encode(uint8_t *output, size_t avail, const proto_egl85_t *input);
/** Check whether the internal state of the proto_egl85 in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *proto_egl85_check(const proto_egl85_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int proto_egl85_clear_errors(proto_egl85_t *obj);
/** Return the value of the task field of the proto_egl85_t in 'inp'
 */
uint8_t proto_egl85_get_task(proto_egl85_t *inp);
/** Set the value of the task field of the proto_egl85_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int proto_egl85_set_task(proto_egl85_t *inp, uint8_t val);
/** Return the value of the tasks_player field of the proto_egl85_t in
 * 'inp'
 */
uint8_t proto_egl85_get_tasks_player(proto_egl85_t *inp);
/** Set the value of the tasks_player field of the proto_egl85_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int proto_egl85_set_tasks_player(proto_egl85_t *inp, uint8_t val);
/** Return the value of the tasks_msgs field of the proto_egl85_t in
 * 'inp'
 */
struct proto_egl85_messages_st * proto_egl85_get_tasks_msgs(proto_egl85_t *inp);
/** Set the value of the tasks_msgs field of the proto_egl85_t in
 * 'inp' to 'val'. Free the old value if any. Steals the referenceto
 * 'val'.Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int proto_egl85_set_tasks_msgs(proto_egl85_t *inp, struct proto_egl85_messages_st *val);
/** As proto_egl85_set_tasks_msgs, but does not free the previous
 * value.
 */
int proto_egl85_set0_tasks_msgs(proto_egl85_t *inp, struct proto_egl85_messages_st *val);
/** Return the value of the tasks_selection field of the proto_egl85_t
 * in 'inp'
 */
uint8_t proto_egl85_get_tasks_selection(proto_egl85_t *inp);
/** Set the value of the tasks_selection field of the proto_egl85_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int proto_egl85_set_tasks_selection(proto_egl85_t *inp, uint8_t val);
/** Return a newly allocated domain_protocol with all elements set to
 * zero.
 */
domain_protocol_t *domain_protocol_new(void);
/** Release all storage held by the domain_protocol in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void domain_protocol_free(domain_protocol_t *victim);
/** Try to parse a domain_protocol from the buffer in 'input', using
 * up to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * domain_protocol_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t domain_protocol_parse(domain_protocol_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * domain_protocol in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t domain_protocol_encoded_len(const domain_protocol_t *obj);
/** Try to encode the domain_protocol from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t domain_protocol_encode(uint8_t *output, size_t avail, const domain_protocol_t *input);
/** Check whether the internal state of the domain_protocol in 'obj'
 * is consistent. Return NULL if it is, and a short message if it is
 * not.
 */
const char *domain_protocol_check(const domain_protocol_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int domain_protocol_clear_errors(domain_protocol_t *obj);
/** Return the value of the name field of the domain_protocol_t in
 * 'inp'
 */
uint8_t domain_protocol_get_name(domain_protocol_t *inp);
/** Set the value of the name field of the domain_protocol_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_protocol_set_name(domain_protocol_t *inp, uint8_t val);
/** Return the value of the proto_egl85 field of the domain_protocol_t
 * in 'inp'
 */
struct proto_egl85_st * domain_protocol_get_proto_egl85(domain_protocol_t *inp);
/** Set the value of the proto_egl85 field of the domain_protocol_t in
 * 'inp' to 'val'. Free the old value if any. Steals the referenceto
 * 'val'.Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_protocol_set_proto_egl85(domain_protocol_t *inp, struct proto_egl85_st *val);
/** As domain_protocol_set_proto_egl85, but does not free the previous
 * value.
 */
int domain_protocol_set0_proto_egl85(domain_protocol_t *inp, struct proto_egl85_st *val);
/** Return a newly allocated domain_base with all elements set to
 * zero.
 */
domain_base_t *domain_base_new(void);
/** Release all storage held by the domain_base in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void domain_base_free(domain_base_t *victim);
/** Try to parse a domain_base from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * domain_base_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t domain_base_parse(domain_base_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * domain_base in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t domain_base_encoded_len(const domain_base_t *obj);
/** Try to encode the domain_base from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t domain_base_encode(uint8_t *output, size_t avail, const domain_base_t *input);
/** Check whether the internal state of the domain_base in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *domain_base_check(const domain_base_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int domain_base_clear_errors(domain_base_t *obj);
/** Return the value of the version field of the domain_base_t in
 * 'inp'
 */
uint8_t domain_base_get_version(domain_base_t *inp);
/** Set the value of the version field of the domain_base_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_base_set_version(domain_base_t *inp, uint8_t val);
/** Return the value of the length field of the domain_base_t in 'inp'
 */
uint32_t domain_base_get_length(domain_base_t *inp);
/** Set the value of the length field of the domain_base_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int domain_base_set_length(domain_base_t *inp, uint32_t val);
/** Return the value of the message_domain field of the domain_base_t
 * in 'inp'
 */
uint8_t domain_base_get_message_domain(domain_base_t *inp);
/** Set the value of the message_domain field of the domain_base_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int domain_base_set_message_domain(domain_base_t *inp, uint8_t val);
/** Return the value of the domain_message_domcon field of the
 * domain_base_t in 'inp'
 */
struct domain_control_st * domain_base_get_domain_message_domcon(domain_base_t *inp);
/** Set the value of the domain_message_domcon field of the
 * domain_base_t in 'inp' to 'val'. Free the old value if any. Steals
 * the referenceto 'val'.Return 0 on success; return -1 and set the
 * error code on 'inp' on failure.
 */
int domain_base_set_domain_message_domcon(domain_base_t *inp, struct domain_control_st *val);
/** As domain_base_set_domain_message_domcon, but does not free the
 * previous value.
 */
int domain_base_set0_domain_message_domcon(domain_base_t *inp, struct domain_control_st *val);
/** Return the value of the domain_message_domproto field of the
 * domain_base_t in 'inp'
 */
struct domain_protocol_st * domain_base_get_domain_message_domproto(domain_base_t *inp);
/** Set the value of the domain_message_domproto field of the
 * domain_base_t in 'inp' to 'val'. Free the old value if any. Steals
 * the referenceto 'val'.Return 0 on success; return -1 and set the
 * error code on 'inp' on failure.
 */
int domain_base_set_domain_message_domproto(domain_base_t *inp, struct domain_protocol_st *val);
/** As domain_base_set_domain_message_domproto, but does not free the
 * previous value.
 */
int domain_base_set0_domain_message_domproto(domain_base_t *inp, struct domain_protocol_st *val);
/** Return the value of the domain_message_domstat field of the
 * domain_base_t in 'inp'
 */
struct domain_status_st * domain_base_get_domain_message_domstat(domain_base_t *inp);
/** Set the value of the domain_message_domstat field of the
 * domain_base_t in 'inp' to 'val'. Free the old value if any. Steals
 * the referenceto 'val'.Return 0 on success; return -1 and set the
 * error code on 'inp' on failure.
 */
int domain_base_set_domain_message_domstat(domain_base_t *inp, struct domain_status_st *val);
/** As domain_base_set_domain_message_domstat, but does not free the
 * previous value.
 */
int domain_base_set0_domain_message_domstat(domain_base_t *inp, struct domain_status_st *val);


#endif
